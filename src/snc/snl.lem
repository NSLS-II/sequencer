%include {
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "parse.h"
#include "snc_main.h"
}

%extra_argument { Expr **presult }

%name snlParser

%parse_failure {
	report("parser giving up\n");
	exit(1);
}

%syntax_error {
	error_at(TOKEN.file, TOKEN.line,
		"syntax error near token '%s'\n", TOKEN.str);
}

%token_type { Token }
%default_type { Expr* }

/* Standard C operator table
  Primary Expression Operators  () [] . -> expr++ expr--  left-to-right
  Unary Operators  * & + - ! ~ ++expr --expr (typecast) sizeof()  right-to-left
  Binary Operators  * / %  left-to-right
  + -
  >> <<
  < > <= >=
  == !=
  &
  ^
  |
  &&
  ||
  Ternary Operator  ?:  right-to-left
  Assignment Operators  = += -= *= /= %= >>= <<= &= ^= |=  right-to-left
  Comma  ,  left-to-right
*/

// PRE and POST are pseudo tokens, they only for the
// precedence declaration.

// We do not support the comma operator, except
// in for(;;), where it is built-in.
// %left	COMMA.

%right	EQUAL ADDEQ SUBEQ ANDEQ OREQ
	DIVEQ MULEQ MODEQ LSHEQ RSHEQ XOREQ.
%right	QUESTION COLON.
%left	OROR.
%left	ANDAND.
%left	VBAR.
%left	CARET.
%left	AMPERSAND.
%left	EQ NE.
%left	GT GE LE LT.
%left	LSHIFT RSHIFT.
%left	ADD SUB.
%left	ASTERISK SLASH MOD.
%right	NOT INCR DECR PRE.
%left	LBRACKET RBRACKET POINTER PERIOD POST.
// LPAREN RPAREN not listed as we do not support indirect calls. */

program ::=
	PROGRAM NAME(n)
	program_param(pp)
	global_defns(ds)
	entry(en)
	state_sets(ss)
	exit(ex)
	c_codes(cc).
{
	*presult =  expr(D_PROG, n, pp, ds, en, ss, ex, cc);
}

program_param(p) ::=
	LPAREN string(x) RPAREN.	{ p = x; }
program_param(p) ::= .			{ p = 0; }

// Definitions

global_defns(p) ::= global_defns(xs) global_defn(x). {
	p = link_expr(xs, x);
}
global_defns(p) ::= global_defn(x).	{ p = x; }

global_defn(p) ::= assign(x).		{ p = x; }
global_defn(p) ::= monitor(x).		{ p = x; }
global_defn(p) ::= sync(x).		{ p = x; }
global_defn(p) ::= syncq(x).		{ p = x; }
global_defn(p) ::= decl(x).		{ p = x; }
global_defn(p) ::= evflag_decl(x).	{ p = x; }
global_defn(p) ::= foreign_decl(x).	{ p = x; }
global_defn(p) ::= option(x).		{ p = x; }
global_defn(p) ::= c_code(x).		{ p = x; }

assign(p) ::= ASSIGN NAME(v) to string(t) SEMICOLON. {
	p = expr(D_ASSIGN, v, 0, t);
}
assign(p) ::= ASSIGN NAME(v) subscript(s) to string(t) SEMICOLON. {
	p = expr(D_ASSIGN, v, expr(E_CONST, s), t);
}
assign(p) ::= ASSIGN NAME(v) to LBRACE strings(ss) RBRACE SEMICOLON. {
	p = expr(D_ASSIGN, v, 0, ss);
}

strings(p) ::= strings(xs) COMMA string(x). {
	p = link_expr(xs, x);
}
strings(p) ::= string(x). {
	p = x;
}

monitor(p) ::= MONITOR NAME(v) opt_subscript(s) SEMICOLON. {
	p = expr(D_MONITOR, v, s);
}

sync(p) ::= SYNC NAME(v) opt_subscript(s) to NAME(ev) SEMICOLON. {
	p = expr(D_SYNC, v, s, expr(E_VAR, ev), 0);
}

syncq(p) ::= SYNCQ NAME(v) opt_subscript(s) to NAME(ev) syncq_size(n) SEMICOLON. {
	p = expr(D_SYNCQ, v, s, expr(E_VAR, ev), n);
}

syncq_size(p) ::= INTCON(n).		{ p = expr(E_CONST, n); }
syncq_size(p) ::= .			{ p = 0; }

to ::= TO.
to ::= .

opt_subscript(p) ::= subscript(s).	{ p = expr(E_CONST, s); }
opt_subscript(p) ::= .			{ p = 0; }

%type subscript {Token}
subscript(p) ::= LBRACKET INTCON(n) RBRACKET. { p = n; }

foreign_decl(p) ::= DECLARE NAME(v) SEMICOLON.
			{ p = decl(V_NONE,   VC_FOREIGN, v, 0, 0, 0); }

evflag_decl(p) ::= EVFLAG NAME(v) SEMICOLON.
			{ p = decl(V_NONE, VC_EVFLAG, v, 0, 0, 0); }

decl(p) ::= type(t) NAME(v) SEMICOLON.
			{ p = decl(t, VC_SCALAR,  v, 0,  0,  0); }
decl(p) ::= type(t) NAME(v) EQUAL expr(x) SEMICOLON.
			{ p = decl(t, VC_SCALAR,  v, 0,  0, x); }
decl(p) ::= type(t) NAME(v) subscript(s) SEMICOLON.
			{ p = decl(t, VC_ARRAY1,  v, s.str,  0,  0); }
decl(p) ::= type(t) NAME(v) subscript(s1) subscript(s2) SEMICOLON.
			{ p = decl(t, VC_ARRAY2,  v, s1.str, s2.str, 0); }
decl(p) ::= type(t) ASTERISK NAME(v) SEMICOLON.
			{ p = decl(t, VC_POINTER, v, 0, 0, 0); }
decl(p) ::= type(t) ASTERISK NAME(v) subscript(s) SEMICOLON.
			{ p = decl(t, VC_ARRAYP,  v, s.str,  0,  0); }

%type number {Token}
number(p) ::= INTCON(x).			{ p = x; }
number(p) ::= FPCON(x).				{ p = x; }

%type type {int}
type(p) ::= CHAR.				{ p = V_CHAR;	}
type(p) ::= SHORT.				{ p = V_SHORT;	}
type(p) ::= INT.				{ p = V_INT;	}
type(p) ::= LONG.				{ p = V_LONG;	}
type(p) ::= UNSIGNED CHAR.			{ p = V_UCHAR;	}
type(p) ::= UNSIGNED SHORT.			{ p = V_USHORT;	}
type(p) ::= UNSIGNED INT.			{ p = V_UINT;	}
type(p) ::= UNSIGNED LONG.			{ p = V_ULONG;	}
type(p) ::= FLOAT.				{ p = V_FLOAT;	}
type(p) ::= DOUBLE.				{ p = V_DOUBLE;	}
type(p) ::= STRING.				{ p = V_STRING;	}

option(p) ::= OPTION option_value(v) NAME(n) SEMICOLON.
						{ p = opt_defn(n, v); }

%type option_value {Token}
option_value(p) ::= ADD(t).			{ p = t; }
option_value(p) ::= SUB(t).			{ p = t; }

// State sets and states

//global_entry_code(p) ::= ENTRY block(xs).	{ p = xs.right; }
//global_entry_code(p) ::= .			{ p = 0; }

//global_exit_code(p) ::= EXIT block(xs).		{ p = xs.right; }
//global_exit_code(p) ::= .			{ p = 0; }

state_sets(p) ::= state_sets(xs) state_set(x).	{ p = link_expr(xs, x); }
state_sets(p) ::= state_set(x).			{ p = x; }

state_set(p) ::= SS NAME(n) LBRACE ss_defns(ds) states(xs) RBRACE.
						{ p = expr(D_SS, n, ds, xs); }

ss_defns(p) ::= ss_defns(xs) ss_defn(x). {
	p = link_expr(xs, x);
}
ss_defns(p) ::= .				{ p = 0; }

ss_defn(p) ::= assign(x).			{ p = x; }
ss_defn(p) ::= monitor(x).			{ p = x; }
ss_defn(p) ::= sync(x).				{ p = x; }
ss_defn(p) ::= syncq(x).			{ p = x; }
ss_defn(p) ::= decl(x).				{ p = x; }

states(p) ::= states(xs) state(x).		{ p = link_expr(xs, x); }
states(p) ::= state(x).				{ p = x; }

state(p) ::=
	STATE NAME(n) LBRACE state_defns(ds)
	entry(en) whens(ws) exit(ex) RBRACE.
{
	p = expr(D_STATE, n, ds, en, ws, ex);
}

state_defns(p) ::= state_defns(xs) state_defn(x). {
	p = link_expr(xs, x);
}
state_defns(p) ::= .				{ p = 0; }

state_defn(p) ::= assign(x).			{ p = x; }
state_defn(p) ::= monitor(x).			{ p = x; }
state_defn(p) ::= sync(x).			{ p = x; }
state_defn(p) ::= syncq(x).			{ p = x; }
state_defn(p) ::= decl(x).			{ p = x; }
state_defn(p) ::= option(x).			{ p = x; }

entry(p) ::= ENTRY(t) block(b).			{ p = expr(D_ENTRY, t, b.left, b.right); }
entry(p) ::= .					{ p = 0; }

exit(p) ::= EXIT(t) block(b).			{ p = expr(D_EXIT, t, b.left, b.right); }
exit(p) ::= .					{ p = 0; }

whens(p) ::= whens(xs) when(x).			{ p = link_expr(xs, x); }
whens(p) ::= when(x).				{ p = x; }

when(p) ::= WHEN(t) LPAREN opt_expr(c) RPAREN block(b) STATE NAME(n). {
	t.str = n.str;
	p = expr(D_WHEN, t, c, b.left, b.right);
}

%type block {ExprPair}
block(p) ::= LBRACE block_defns(ds) statements(xs) RBRACE. {
	p = (ExprPair){ds,xs};
}

block_defns(p) ::= block_defns(ds) block_defn(d). {
	p = link_expr(ds, d);
}
block_defns(p) ::= .				{ p = 0; }

block_defn(p) ::= decl(x).			{ p = x; }
block_defn(p) ::= c_code(x).			{ p = x; }

// Statements

statements(p) ::= statements(xs) statement(x).	{ p = link_expr(xs, x); }
statements(p) ::= .				{ p = 0; }

statement(p) ::= BREAK(t) SEMICOLON.		{ p = expr(S_JUMP, t); }
statement(p) ::= CONTINUE(t) SEMICOLON.		{ p = expr(S_JUMP, t); }
statement(p) ::= STATE NAME(t) SEMICOLON.	{ p = expr(S_CHANGE, t); }
statement(p) ::= c_code(x).			{ p = x; }
statement(p) ::= LBRACE(t) block_defns(ds) statements(xs) RBRACE.
						{ p = expr(S_CMPND, t, ds, xs); }
statement(p) ::= IF(t) LPAREN expr(c) RPAREN statement(th).
						{ p = expr(S_IF, t, c, th, 0); }
statement(p) ::= IF(t) LPAREN expr(c) RPAREN statement(th) ELSE statement(el).
						{ p = expr(S_IF, t, c, th, el); }
statement(p) ::= WHILE(t) LPAREN expr(c) RPAREN statement(x).
						{ p = expr(S_WHILE, t, c, x); }
statement(p) ::= for_statement(x).		{ p = x; }
statement(p) ::= opt_expr(x) SEMICOLON(t).	{ p = expr(S_STMT, t, x); }

for_statement(p) ::=
	FOR(for) LPAREN
	exprs(init) SEMICOLON opt_expr(cond) SEMICOLON exprs(iter)
	RPAREN statement(st).		{ p = expr(S_FOR, for, init, cond, iter, st); }

// Expressions

// Atomic
expr(p) ::= number(x).				{ p = expr(E_CONST, x); }
expr(p) ::= string(x).				{ p = x; }
expr(p) ::= NAME(v).				{ p = expr(E_VAR, v); }

// Parenthesized
expr(p) ::= LPAREN(t) expr(x) RPAREN.		{ p = expr(E_PAREN, t, x); }

// Primary Expression and Unary Postfix Operators
expr(p) ::= NAME(t) LPAREN exprs(xs) RPAREN.	 [POST] { p = expr(E_FUNC,   t, xs); }
expr(p) ::= EXIT(t) LPAREN exprs(xs) RPAREN.	 [POST] { p = expr(E_FUNC,   t, xs); }
expr(p) ::= DELAY(t) LPAREN exprs(xs) RPAREN.	 [POST] { p = expr(E_DELAY,  t, xs); }
expr(p) ::= expr(x) LBRACKET(t) expr(y) RBRACKET.[POST] { p = expr(E_SUBSCR, t, x, y); }
expr(p) ::= expr(x) PERIOD(t)  expr(y).		 [POST] { p = expr(E_BINOP,  t, x, y); }
expr(p) ::= expr(x) POINTER(t) expr(y).		 [POST] { p = expr(E_BINOP,  t, x, y); }
expr(p) ::= expr(x) INCR(t).			 [POST] { p = expr(E_POST,   t, x); }
expr(p) ::= expr(x) DECR(t).			 [POST] { p = expr(E_POST,   t, x); }

// Unary Prefix Operators
expr(p) ::= ADD(t)	expr(x). [PRE]		{ p = expr(E_PRE, t, x); }
expr(p) ::= SUB(t)	expr(x). [PRE]		{ p = expr(E_PRE, t, x); }
expr(p) ::= ASTERISK(t)	expr(x). [PRE]		{ p = expr(E_PRE, t, x); }
expr(p) ::= AMPERSAND(t)expr(x). [PRE]		{ p = expr(E_PRE, t, x); }
expr(p) ::= NOT(t)	expr(x). [PRE]		{ p = expr(E_PRE, t, x); }
expr(p) ::= TILDE(t)	expr(x). [PRE]		{ p = expr(E_PRE, t, x); }
expr(p) ::= INCR(t)	expr(x). [PRE]		{ p = expr(E_PRE, t, x); }
expr(p) ::= DECR(t)	expr(x). [PRE]		{ p = expr(E_PRE, t, x); }

// Binary Operators, left-to-right
expr(p) ::= expr(x) SUB(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) ADD(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) ASTERISK(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) SLASH(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) GT(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) GE(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) EQ(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) NE(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) LE(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) LT(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) OROR(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) ANDAND(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) LSHIFT(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) RSHIFT(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) VBAR(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) CARET(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) AMPERSAND(t) expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) MOD(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }

// Ternary Operator, right-to-left
expr(p) ::= expr(c) QUESTION(t) expr(th) COLON expr(el).
						{ p = expr(E_TERNOP, t, c, th, el); }

// Assignment Operators, right-to-left
expr(p) ::= expr(x) EQUAL(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) ADDEQ(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) SUBEQ(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) ANDEQ(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) OREQ(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) DIVEQ(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) MULEQ(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) MODEQ(t) 	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) LSHEQ(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) RSHEQ(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }
expr(p) ::= expr(x) XOREQ(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }

// Comma, left-to-right, not supported
// expr(p) ::= expr(x) COMMA(t)	expr(y).	{ p = expr(E_BINOP, t, x, y); }

opt_expr(p) ::= expr(x).			{ p = x; }
opt_expr(p) ::= .				{ p = 0; }

exprs(p) ::= exprs(xs) COMMA expr(x).		{ p = link_expr(xs, x); }
exprs(p) ::= expr(x).				{ p = x; }
exprs(p) ::= .					{ p = 0; }

string(p) ::= STRCON(t).			{ p = expr(E_STRING, t); }

// Literal (C) code

c_codes(p) ::= c_codes(xs) c_code(x).		{ p = link_expr(xs, x); }
c_codes(p) ::= .				{ p = 0; }

c_code(p) ::= CCODE(t). 			{ p = expr(T_TEXT, t); }
