/**************************************************************************
			GTA PROJECT   AT division
	Copyright, 1989-93, The Regents of the University of California.
		         Los Alamos National Laboratory

 	parse.h,v 1.2 1995/06/27 15:25:50 wright Exp
	DESCRIPTION: Structures for parsing the state notation language.
	ENVIRONMENT: UNIX
	HISTORY:
18nov91,ajk	Replaced lstLib stuff with in-line links.
28oct93,ajk	Added support for assigning array elements to pv's.
28oct93,ajk	Added support for pointer declarations (see VC_*)
05nov93,ajk	Changed structures var & db_chan to handle array assignments.
05nov93,ajk	changed malloc() to calloc() 3 places.
20jul95,ajk	Added unsigned types (V_U...).
08aug96,wfl	Added syncQ variables to var struct.
01sep99,grw     Added E_OPTION, E_ENTRY, E_EXIT.
07sep99,wfl	Added E_DECL (for local variable declarations).
***************************************************************************/

#ifndef INCLparseh
#define INCLparseh

/* Data for these blocks are generated by the parsing routines for each
** state set.  The tables are then used to generate the run-time C code
** for the sequencer.  This decouples the parsing implementation from
** the run-time code implementation.
*/

struct	scope
{
	struct	var_list *var_list;
	struct	scope *next;
};
typedef struct	scope Scope;

struct	expression			/* Expression block */
{
	struct	expression *next;	/* link to next expression */
	struct	expression *last;	/* link to last in list */
	struct	expression *left;	/* ptr to left expression */
	struct	expression *right;	/* ptr to right expression */
	int	type;			/* expression type (E_*) */
	char	*value;			/* operator or value string */
	int	line_num;		/* line number */
	char	*src_file;		/* effective source file */
};
typedef	struct	expression Expr;

struct	var				/* Variable or function definition */
{
	struct	var *next;		/* link to next item in list */
	char	*name;			/* variable name */
	char	*value;			/* initial value or NULL */
	int	type;			/* var type */
	int	class;			/* simple, array, or pointer */
	int	length1;		/* 1st dim. array lth (default=1) */
	int	length2;		/* 2nd dim. array lth (default=1) */
	int	ef_num;			/* bit number if this is an event flag */
	struct	db_chan *chan;		/* ptr to channel struct if assigned */
	int	queued;			/* whether queued via syncQ */
	int	maxQueueSize;		/* max syncQ queue size */
	int	queueIndex;		/* index in syncQ queue array */
	int	line_num;		/* line number */
};
typedef	struct	var Var;

struct	db_chan				/* DB channel assignment info */
{
	struct	db_chan *next;		/* link to next item in list */
	char	*db_name;		/* database name (assign all to 1 pv) */
	char	**db_name_list;		/* list of db names (assign each to a pv) */
	int	num_elem;		/* number of elements assigned in db_name_list */
	Var	*var;			/* ptr to variable definition */
	int	count;			/* count for db access */
	int	mon_flag;		/* TRUE if channel is "monitored" */
	int	*mon_flag_list;		/* ptr to list of monitor flags */
	Var	*ef_var;		/* ptr to event flag variable for sync */
	Var	**ef_var_list;		/* ptr to list of event flag variables */
	int	ef_num;			/* event flag number */
	int	*ef_num_list;		/* list of event flag numbers */
	int	index;			/* index in database channel array (seqChan) */
};
typedef	struct	db_chan Chan;
/* Note: Only one of db_name or db_name_list can have a non-zero value */

struct chan_list
{
	Chan	*first, *last;
};
typedef struct	chan_list ChanList;

struct var_list
{
	Var	*first, *last;
};
typedef struct	var_list VarList;

struct parse				/* result of parsing */
{
	char	*prog_name;		/* ptr to program name (string) */
	char	*prog_param;		/* parameter string for program stmt */
	Expr	*global_defn_list;	/* global definition list */
	Expr	*ss_list;		/* state set list */
	Expr	*entry_code_list;	/* entry code list */
	Expr	*exit_code_list;	/* exit code list */
	Scope	*global_scope;		/* global scope */
	ChanList *chan_list;		/* channel list */
	Expr	*global_c_list;		/* global C code following state program */
	int	num_channels;		/* number of db channels */
	int	num_events;		/* number of event flags */
	int	num_queues;		/* number of syncQ queues */
	int	num_ss;			/* number of state sets */
};
typedef struct parse Parse;

/* Allocation 'functions' */
#define	allocExpr()		(Expr *)calloc(1, sizeof(Expr))
#define	allocVar()		(Var *)calloc(1, sizeof(Var))
#define	allocChan()		(Chan *)calloc(1, sizeof(Chan))
#define	allocVarList()		(VarList *)calloc(1, sizeof(VarList))
#define	allocChanList()		(ChanList *)calloc(1, sizeof(ChanList))
#define	allocScope()		(Scope *)calloc(1, sizeof(Scope))
#define	allocParse()		(Parse *)calloc(1, sizeof(Parse))

/* Variable types */
#define	V_NONE		0		/* not defined */
#define	V_CHAR		1		/* char */
#define	V_SHORT		2		/* short */
#define	V_INT		3		/* int */
#define	V_LONG		4		/* long */
#define	V_FLOAT		5		/* float */
#define	V_DOUBLE	6		/* double */
#define	V_STRING	7		/* strings (array of char) */
#define	V_EVFLAG	8		/* event flag */
#define	V_FUNC		9		/* function (not a variable) */
#define	V_UCHAR		11		/* unsigned char */
#define	V_USHORT	12		/* unsigned short */
#define	V_UINT		13		/* unsigned int */
#define	V_ULONG		14		/* unsigned long */

/* Variable classes */
#define	VC_SIMPLE	0		/* simple (un-dimensioned) variable */
#define	VC_ARRAY1	1		/* single dim. array */
#define	VC_ARRAY2	2		/* multiple dim. array */
#define	VC_POINTER	3		/* pointer */
#define	VC_ARRAYP	4		/* array of pointers */

/* Expression types */
enum expr_type {
	E_CONST,		/* numeric constant */
	E_STRING,		/* ptr to string constant */
	E_VAR,			/* variable */
	E_PAREN,		/* parenthesis around an expression */
	E_FUNC,			/* function */
	E_SUBSCR,		/* subscript: expr[expr] */
	E_POST,			/* unary postfix operator: expr OP */
	E_PRE,			/* unary prefix operator: OP expr */
	E_BINOP,		/* binary operator: expr OP expr */
	E_TERNOP,		/* ternary operator: expr OP expr OP expr */
	E_TEXT,			/* C code or other text to be inserted */
	E_STMT,			/* simple statement */
	E_CMPND,		/* begin compound statement: {...} */
	E_IF,			/* if statement */
	E_ELSE,			/* else statement */
	E_WHILE,		/* while statement */
	E_SS,			/* state set statement */
	E_STATE,		/* state statement */
	E_WHEN,			/* when statement */
	E_FOR,			/* for statement */
	E_X,			/* eXpansion (e.g. for(;;) */
	E_BREAK,		/* break stmt */
	E_DECL,			/* declaration statement */
	E_ENTRY,		/* entry statement */
	E_EXIT,			/* exit statement */
	E_OPTION,		/* state option statement */
	E_ASSIGN,		/* assign statement */
	E_MONITOR,		/* monitor statement */
	E_SYNC,			/* sync statement */
	E_SYNCQ			/* syncq statement */
};
typedef enum expr_type ExprType;

#ifdef expr_type_GLOBAL
const char *expr_type_names[] =
{
	"E_CONST",
	"E_STRING",
	"E_VAR",	
	"E_PAREN",
	"E_FUNC",	
	"E_SUBSCR",
	"E_POST",	
	"E_PRE",	
	"E_BINOP",
	"E_TERNOP",
	"E_TEXT",	
	"E_STMT",	
	"E_CMPND",
	"E_IF",	
	"E_ELSE",	
	"E_WHILE",
	"E_SS",	
	"E_STATE",
	"E_WHEN",	
	"E_FOR",	
	"E_X",	
	"E_BREAK",
	"E_DECL",	
	"E_ENTRY",
	"E_EXIT",	
	"E_OPTION",
	"E_ASSIGN",
	"E_MONITOR",
	"E_SYNC",
	"E_SYNCQ"
};
#else
extern const char *expr_type_names[];
#endif

void program(
	char *pname,
	char *pparam,
	Expr *defn_list,
	Expr *entry_list,
	Expr *prog_list,
	Expr *exit_list,
	Expr *c_list
);
Expr *expression(
	int	type,		/* E_BINOP, E_ASGNOP, etc */
	char	*value,		/* "==", "+=", var name, constant, etc. */
	Expr	*left,		/* LH side */
	Expr	*right		/* RH side */
);
Expr *declaration(
	int	type,		/* variable type (e.g. V_FLOAT) */
	int	class,		/* variable class (e.g. VC_ARRAY) */
	char	*name,		/* ptr to variable name */
	char	*s_length1,	/* array lth (1st dim, arrays only) */
	char	*s_length2,	/* array lth (2nd dim, [n]x[m] arrays only) */
	char	*value		/* initial value or NULL */
);
void option_stmt(
	char	*option,	/* "a", "r", ... */
	int	value		/* TRUE means +, FALSE means - */
);
void add_var(
	Scope *scope,		/* scope to add variable to */
	Var *vp			/* variable to add */
);
Var *find_var(
	Scope *scope,		/* scope where to first search for the variable */
	char *name		/* variable name to find */
);
Expr *link_expr(
	Expr	*ep1,		/* beginning of 1-st structure or list */
	Expr	*ep2		/* beginning 2-nd (append it to 1-st) */
);
Expr *c_code(
	char	*value;
	int	line_num;
);

#endif	/*INCLparseh*/
