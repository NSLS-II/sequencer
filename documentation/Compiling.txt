Compiling SNL Programs
======================

Files needed
------------

In order to compile and run a sequencer program, a C/C++ compiler and
the following files are required.

#. **snc**, the SNL compiler executable
#. sequencer include files *seqCom.h* and *pvAlarm.h*
#. EPICS include files *shareLib.h*, *epicsTypes.h* and
   *tsStamp.h*
#. if using the *+m* compiler option, EPICS include files
   *osiThread.h*, *osiSem.h*, *errlog.h* and *taskwd.h* (and files
   included by them)
#. sequencer libraries *libseq* and *libpv* (for vxWorks IOCs, you
   can use the dynamically loadable object libs *seqLibrary.o* and
   *pvLibrary.o*)
#. libraries for any message systems other than CA
#. EPICS libraries *libca* (if using CA) and *libCom* (for vxWorks
   IOCs, you can also use vxComLibrary.o)

SNC, the SNL Compiler
---------------------

The SNL compiler (SNC) converts the state notation
language into C code, which is then compiled to produce a
run-time object module. The C pre-processor may be used prior to
SNC. If we have a state program file named *test.st* then the steps
to compile are similar to the following::

  snc test.st
  gcc -c test.c -o test.o ...additional compiler options...
  gcc test.o -o test ...additional linker options...

Alternatively, using the C pre-processor::

  gcc -E -x c test.st >test.i
  snc test.i
  gcc -c test.c -o test.o ...additional compiler options...
  gcc test.o -o test ...additional linker options...

Using the C pre-processor allows you to include SNL files (``#include``
directive), to use ``#define`` directives, and to perform conditional
compilation (e.g. ``#ifdef``).

.. image:: Figure3-1.png

Name of output file
-------------------

The output file name is that of the input file with the extension
replaced with *.c*. The *-o* option can be used to override the output
file name.

Actually the rules are a little more complex than stated above: *.st*
and single-character extensions are replaced with *.c*; otherwise *.c*
is appended to the full file name. In all cases, the *-o* compiler
option overrides.

.. _CompilerOptions:

Compiler Options
----------------

SNC options start by a plus or minus sign, followed by a single
character. A plus sign turns the option on, and a minus turns the
option off.

======  ===============================================================
Option  Description
======  ===============================================================
  +a    Asynchronous ``pvGet``: the program continues without
        waiting for completion of the ``pvGet`` operation.
  -a    ``pvGet`` waits for completion. This is the
        default if an option is not specified.
  +c    Wait for process variables to connect before allowing the
        program to begin execution. This is the default.
  -c    Allow the program to begin execution before connections
        are established to all channel.
  +d    Turn on run-time debug messages.
  -d    Turn off run-time debug messages. This is the default.
  +e    Use the new event flag mode. This is the default.
  -e    Use the old event flag mode (clear flags after executing a
        when statement).
  +l    Add line markers to the generated code, so that C compiler
        messages refer to the SNL source file. This is the default.
  -l    Do not produce line markers.
  +m    Generate a main procedure for a stand-alone program.
  -m    Do not generate a main procedure. This is the default.
  +r    Make the generated code reentrant, thus allowing more than one
        instance of the state program to run on an IOC.
  -r    Generated code is not reentrant. This is the default.
  +w    Display SNC warning messages. This is the default.
  -w    Suppress SNC warnings.
======  ===============================================================

Options may also be set from within the program (somewhere between the
program name/parameter and the state set definitions). For example::

  option +r;
  option -c;

See :ref:`global_option` in the :doc:`Reference`.

Compiler Errors
---------------

If *snc* detects an error, it displays a message describing the error
and the location in the source file and aborts further compilation.
Note, however, that *snc* does *not* contain a type checker: all it
knows (and cares) about C is the syntax. This means that many errors
will only be found only during the C compilation phase. The C compiler
will attributed these to the corresponding location in the SNL source
file, since by default *snc* generates line markers in the output that
point back to the original source. This can be turned off with the *-l*
("ell") compiler switch.

Compiler Warnings
-----------------

In certain cases *snc* cannot finally judge whether the code is
erroneous. In such cases it will issue a warning message and continue.

The most prominent example is the use of a variable or CPP macro that
has not been declared in the SNL code, but could well be defined when
compiling the generated C code (for example if the declaration has been
in embedded C code, which *snc* does not interpret at all). Warnings
can be suppressed with the *-w* compiler option.

Note that since version 2.1 you can avoid these warnings by declaring
such variables in SNL, see the :ref:`foreign_decl` statement.

Compiling and Linking a State Program under Unix
------------------------------------------------

Under Unix, either the *+m* compiler option should be used to
create a C main program or else the programmer should write a main
program (the main program plays the same role as the VxWorks
startup script).

Here is a full build of a simple state program from source under
Solaris. Compiler and loader options will vary with other operating
systems. It is assumed that the sequencer is in
*/usr/local/epics/seq* and that EPICS is in */usr/local/epics*.

::

  gcc -E -x c demo.st >demo.i
  snc +m demo.i

  gcc -D_POSIX_C_SOURCE=199506L -D_POSIX_THREADS -D_REENTRANT\
  -D__EXTENSIONS__ -DnoExceptionsFromCXX \
  -DOSITHREAD_USE_DEFAULT_STACK \
  -I. -I.. \
  -I/usr/local/epics/seq/include \
  -I/usr/local/epics/base/include/os/solaris \
  -I/usr/local/epics/base/include -c demo.c
  g++ -o demo \
  -L/usr/local/epics/seq/lib/solaris-sparc \
  -L/usr/local/epics/base/lib/solaris-sparc \
  demo.o -lseq -lpv -lpvCa -lca -lCom \
  -lposix4 -lpthread -lthread -lsocket -lnsl -lm

The main program generated by the *+m* compiler option is very
simple. Here it is::

  /* Main program */
  #include "osiThread.h"
  #include "errlog.h"
  #include "taskwd.h"

  int main(int argc,char *argv[]) {
    char *macro_def = (argc>1)?argv[1]:NULL;
    threadInit();
    errlogInit(0);
    taskwdInit();
    return seq((void *)&demo, macro_def, 0);
  }

The arguments are essentially the same as those taken by the ``seq``
routine.

.. _UsingmakeBaseApp:

Using makeBaseApp
-----------------

The sequencer is distributed as an EPICS R3.14 *makeBaseApp*
application. This section doesn't describe how to install and build
the sequencer itself (for that, refer to :doc:`Installation`); instead, it describes
how to build a sequencer application.

Makefile
^^^^^^^^

Assume a sequencer in *demo.st*. This sequencer will use the CA
message system. It is to be linked into a Unix program called *demo*
and a VxWorks object file called *demo.o*. Also assume that the
sequencer ist installed at ``SNCSEQ`` (see
:ref:`using-the-installation`). The following *Makefile* does the job::

  TOP = ../..
  include $(TOP)/configure/CONFIG

  SNCFLAGS = +m
  SEQS = demo
  PROD = $(SEQS)
  OBJS_vxWorks = $(SEQS)

  PROD_LIBS += seq pv pvCa ca Com
  seq_DIR = $(SEQ_LIB)

  include $(TOP)/configure/RULES
