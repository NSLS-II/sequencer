SNL Reference
=============

This chapter is supposed to give a detailed reference for the SNL
syntax and semantics.

Formal syntax is given in `BNF`_. Multiple rules for the same
`nonterminal symbol`_ mean that any of the given rules may apply. `Terminal
symbol`_\s are enclosed in double quotes.

.. _BNF: http://en.wikipedia.org/wiki/Backus-Naur_Form
.. _nonterminal symbol: http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Nonterminal_symbols
.. _terminal symbol: http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Terminal_symbols

Lexical Syntax
--------------

Comments
^^^^^^^^

.. productionlist::
   comment: "/*" <anything> "*/"

C-style comments may be placed anywhere in the state program. They are
treated as white space by *snc*. As in C, comments cannot be nested.

Identifiers
^^^^^^^^^^^

.. productionlist::
   identifier: <same as in C>

Identifiers follow the same rules as in C. They are used for variables
(including foreign variables and event flags), the program name,
states, state sets, and options.

Literals
^^^^^^^^

.. productionlist::
   integer_literal: <same as in C>
   floating_point_literal: <same as in C>
   string_literal: <same as in C>

The lexical syntax of identifiers, as well as numeric and string
literals is exactly as in C, including automatic string
concatenation, character literals, and octal, decimal, and
hexadecimal integer literals.

Note that array and struct initializers are not supported.

Embedded C Code
^^^^^^^^^^^^^^^

.. productionlist::
   embedded_c_code: "%{" <anything> "}%"
   embedded_c_code: "%%" <anything> "\n"

A sequence of characters enclosed between "%{" and "}%" is used
literally and without further parsing as if it were a complete
declaration or statement, depending on where it appears.

A sequence of characters enclosed between "%%" and the next line ending
is treated similarly, except that it is stripped of leading and
trailing whitespace and inserted in the output with the current
indentation.

See `Escape to C Code`_ for examples and rationale.

Embedded C code fragments are causing two of the three conflicts in the
grammar. The reason is that the parser cannot decide whether such a
fragment is a declaration or a statement.

Line Markers
^^^^^^^^^^^^

.. productionlist::
   line_marker :: "#" line_number "\n"
   line_marker :: "#" line_number file_name "\n"
   line_number :: <non-empty sequence of decimals>
   file_name :: <like string_literal, without automatic string concatenation>

Line markers are interpreted by *snc* exactly as in C, i.e. they
indicate that the following symbols are really located in the given
source file (if any) at the given line.

Note that line_number may only contain decimal numbers, and that
file_name must be a single string (no automatic string concatenation).

Line markers are typically generated by preprocessors, such as CPP.

.. _StateProgram:

Program
-------

.. productionlist::
   program: "program" `identifier` `program_param` `global_defns` `entry` `state_sets` `exit` `c_codes`

This is the overall structure of an SNL program. After the keyword
"program" comes the name of the program, followed by an optional
program parameter, global definitions, an optional entry block, the
state sets, an optional exit block, and finally some embedded c code.

Program Name and Parameter
^^^^^^^^^^^^^^^^^^^^^^^^^^

The program name is an identifier. It is used as the name of the global
variable which contains or points to all the state program data structures
(the address of this global variable is passed to the ``seq`` function when
creating the run-time sequencer). It is also used as the base for the state
set thread names unless overridden via the *name* parameter (see :ref:`run
time parameters`).

.. productionlist::
   program_param: "(" `string` ")"
   program_param: 

The program name may be followed by an optional string enclosed in
parentheses. The string content must be a list of comma-separated
parameters in the same form as they are specified on the command line
(see :ref:`SpecifyingRunTimeParameters`). Command-line parameters
override those specified here.

.. productionlist::
   global_defns: `global_defns` `global_defn`
   global_defns: `global_defn`
   global_defn: `assign`
   global_defn: `monitor`
   global_defn: `sync`
   global_defn: `syncq`
   global_defn: `decl`
   global_defn: `evflag_decl`
   global_defn: `foreign_decl`
   global_defn: `option`
   global_defn: `c_code`

Global (top-level) definitions, see `Definitions`_ for details.

.. _GlobalEntryExit:

Global Entry and Exit Blocks
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. productionlist::
   entry: "entry" `block`
   entry: 
   exit: "exit" `block`
   exit: 

A state program may specify optional entry code to run prior to state
set thread creation, and exit code to run prior to thread deletion.
Both are run in the context of the first state set thread, before the
other threads are created, resp. after they have been deleted. The
entry or exit code is a regular SNL code block an thus can contain
local definitions. However, no process variable access functions
may be called within the entry code.

.. todo:: check if we can relax this restriction

Global entry and exit blocks should not be confused with the entry and
exit blocks of a state, which have the same syntax, but are executed at
each transition from/to a new state.

Final C Code Block
^^^^^^^^^^^^^^^^^^

.. productionlist::
   c_codes: `c_codes` `c_code`
   c_codes: 
   c_code: `embedded_c_code`

At the end of the program may come any number of embedded
C code blocks. See `Escape to C Code`_.

.. _Definitions:

Definitions
-----------

Declarations
^^^^^^^^^^^^

Scalars
~~~~~~~

.. productionlist::
   decl: `type` `identifier` ";"
   decl: `type` `identifier` "=" `expr` ";"
   type: "char"
   type: "short"
   type: "int"
   type: "long"
   type: "unsigned" "char"
   type: "unsigned" "short"
   type: "unsigned" "int"
   type: "unsigned" "long"
   type: "float"
   type: "double"
   type: "string"

Variable declarations are similar to C but limited in a number of
ways:

*  only integers, floating point numbers are allowed as base types
*  only scalar initialization is permitted
*  only one variable may be declared per declaration

The type ``string`` can be viewed as if it were defined in C as::

   typedef char string[MAX_STRING_SIZE];

where ``MAX_STRING_SIZE`` is supposed to be defined in one of the
included header files form EPICS base. The exact value depends on
the EPICS base version (but in all versions is at least 40).

Arrays and Pointers
~~~~~~~~~~~~~~~~~~~

.. productionlist::
   decl: `type` `identifier` `subscript` ";"
   decl: `type` `identifier` `subscript` `subscript` ";"
   decl: `type` "*" `identifier` ";"
   decl: `type` "*" `identifier` `subscript` ";"

SNL allows declaration of one- or two-dimensional arrays of scalar
elements, as well as pointers to scalars, and (one-dimensional)
arrays of such pointers.

Note that arrays of strings and event flags are not supported.

Event Flags
~~~~~~~~~~~

.. productionlist::
   evflag_decl: "evflag" `identifier` ";"

This declares an event flag, see :ref:`EventFlags`.


Foreign Declarations
~~~~~~~~~~~~~~~~~~~~

.. productionlist::
   foreign_decl: "declare" `identifier` ";"

This declares the named C variable or CPP macro, so the SNL compiler
knows about it. No warning will be issued if such a variable (or macro)
is used in the program.

.. _VariableScope:

Variable Scope
^^^^^^^^^^^^^^

Global variables, that is, variables declared at the top-level (before
any state sets) are visible throughout the program, and persist as long
as the program is running. We say they have *program life time*.

Local variable declarations come in two flavours, depending on where
they appear:

#. Variables of *program life time* are global variables and those
   which are local to a state set or a state clause. Only variables of
   this sort can be assigned to a process variable, monitored, synced
   etc.
#. Variables declared in any other block have lifetime *limited to the
   enclosing block*, they disappear when the block exits, just as block
   local variables in C. They can *not* be assigned to process
   variables.

Process Variables
^^^^^^^^^^^^^^^^^

assign
~~~~~~

.. productionlist::
   assign: "assign" `identifier` `to` `string` ";"
   assign: "assign" `identifier` `subscript` `to` `string` ";"
   assign: "assign" `identifier` `to` "{" `strings` "}" ";"
   to: "to"
   to:
   strings: `strings` "," `string`
   strings: `string`
   subscript: "[" `integer_literal` "]"

This assigns program variables to named process variables.

There are three variants of the :token:`assign` statement. The first one
assigns a (scalar or array) variable to a single process variable.
The second one assigns a single element of an array variable to a
single process variable. The third one assigns elements of an array
variable to separate process variables.

Assigned variables must be of program lifetime, see
:ref:`VariableScope`. Assigned variables, or separately assigned
elements of an array, can be used as argument to built-in ``pvXXX``
procedures (see `Built-in Functions`_). This is the primary means of
interacting with process variables from within a SNL program.

The process variable name may contain macro names enclosed in
braces, as in ``"{sys}{sub}voltage"``. Macros are named following
the same rules as C language variables. Macros are defined via
command line argument, or program parameter (see `Program Name and
Parameter`_). If process variable name is an empty string, then no
actual assignment is performed, but the variable is marked for
potential (dynamic) assignment with :c:func:`pvAssign`.

An array variable assigned wholesale to one process variable (using
the first syntactic variant above) or an element of a
two-dimensional variable assigned to an array process variable
(using the second syntactic variant) will use either the length of
the array (resp. sub-array) or the native count for the underlying
variable, whichever is smaller, when communicating with the
underlying process variable. The native count is determined when the
initial connection is established.

Pointer types may not be assigned to process variables.

monitor
~~~~~~~

.. productionlist::
   monitor: "monitor" `identifier` `opt_subscript` ";"
   opt_subscript: `subscript`
   opt_subscript: 

This sets up a monitor for an assigned variable or array element.

Monitored variables are automatically updated with the
current value of the underlying process variable.

sync
~~~~

.. productionlist::
   sync: "sync" `identifier` `opt_subscript` `to` `identifier` ";"

An event flag can be associated with an SNL variable (which may be
an array, and thus associated with several process
variables). When a monitor is posted on any of the associated
process variables, the corresponding event flag is set (even
if it was already set).


syncQ
~~~~~

.. productionlist::
   syncq: "syncQ" `identifier` `opt_subscript` `to` `identifier` `syncq_size` ";"
   syncq_size: `integer_literal`
   syncq_size: 

An event flag can be associated with a monitor queue which, in
turn, is associated with an SNL variable (which may be an array,
and thus associated with several process variables). The
queue size defaults to 100 but can be overridden on a per-queue
basis. When a monitor is posted on any of the associated process
variables, the variable's value is written to the end of the
queue and the corresponding event flag is set. If the queue is
already full, the last entry is overwritten. Only scalar items can
be accommodated in the queue (if the variable is array-valued, only
the first item will be saved). The :c:func:`pvGetQ` function reads items
from the queue.

.. _option definition:

Option
^^^^^^

.. productionlist::
   option: "option" `option_value` `identifier` ";"
   option_value: "+"
   option_value: "-"

Option values must include the "+" or "-" sign. Example::

  option +r; /* make code reentrant */

The same syntax is used for global options and state options. The
interpretation, however, is different:

Global (top-level) options are interpreted as if the corresponding
compiler option had been given on the command line (see
:ref:`CompilerOptions`).

State options occur inside the state construct and affect only the
state in which they are defined, see `State Option`_.

State Set
---------

.. productionlist::
   state_sets: `state_sets` `state_set`
   state_sets: `state_set`
   state_set: "ss" `identifier` "{" `ss_defns` `states` "}"
   ss_defns: `ss_defns` `ss_defn`
   ss_defns: 

A program may contains one or more state sets. Each state set is
defined by the keyword "ss", followed by the name of the state set (an
identifier). After that comes an opening brace, optionally state set
local definitions, a list of states, and then a closing brace.

State set names must be unique in the program.

State Set Local Definition
^^^^^^^^^^^^^^^^^^^^^^^^^^

.. productionlist::
   ss_defn: `assign`
   ss_defn: `monitor`
   ss_defn: `sync`
   ss_defn: `syncq`
   ss_defn: `decl`

Inside state sets are allowed variable declarations and process variable
definitions (:token:`assign`, :token:`monitor`, :token:`sync`, and
:token:`syncq`).

See `variable scope`_ for details on what local definitions mean.

State
^^^^^

.. productionlist::
   states: `states` `state`
   states: `state`
   state: "state" `identifier` "{" `state_defns` `entry` `whens` `exit` "}"
   state_defns: `state_defns` `state_defn`
   state_defns: 

A state set contains one or more states. Each state is defined by the
keyword "state", followed by the name of the state (and identifier),
followed by an opening brace, optionally state local definitions, an
optional entry block, a list of transitions, an optional exit block,
and finally a closing brace.

State names must be unique in the sate set to which they belong.

State Local Definition
~~~~~~~~~~~~~~~~~~~~~~

.. productionlist::
   state_defn: `assign`
   state_defn: `monitor`
   state_defn: `sync`
   state_defn: `syncq`
   state_defn: `decl`
   state_defn: `option`

.. _StateOption:

State Option
~~~~~~~~~~~~

The syntax for a state option is the same as for global options
(see :ref:`option definition`).

The state options are:

:option:`+t`
   Reset delay timers each time the state is entered, even if entered
   from the same state.

:option:`-t`

   Don't reset delay timers when entering from the same state. In other
   words, the :c:func:`delay` function will return whether the specified
   time has elapsed from the moment the current state was entered from a
   different state, rather than from when it was entered for the current
   iteration.

:option:`+e`
   Execute :token:`entry` blocks only if the previous state was
   not the same as the current state. This is the default.

:option:`-e`
   Execute :token:`entry` blocks even if the previous state was the same
   as the current state.

:option:`+x`
   Execute :token:`exit` blocks only if the next state is not the same as
   the current state. This is the default.

:option:`-x`
   Execute :token:`exit` blocks even if the next state is the same as
   the current state.

For example::

  state low {
    option -e; /* Do entry{} every time ... */
    option +x; /* but only do exit{} when really leaving */
    entry { ... }
    ...
    exit { ... }
  }

.. _state entry and exit blocks:

State Entry and Exit Blocks
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The syntax is the same as for global entry blocks:

.. productionlist::
   entry: "entry" `block`
   entry: 
   exit: "exit" `block`
   exit: 

Entry blocks are executed when the state is entered, before any of the
conditions for state transitions are evaluated.

Exit blocks are executed when the state is left, after the transition
block that determines the next state.

Note that state options can be used to control whether entry/exit
blocks get executed even if the new state is the same as the current
one.

Transitions
~~~~~~~~~~~

.. productionlist::
   whens: `whens` `when`
   whens: `when`
   when: "when" "(" `opt_expr` ")" `block` "state" `identifier`
   opt_expr: `expr`
   opt_expr: 

A state transition starts with the keyword "when", followed by a
condition (in parantheses), followed by a block, and finally the name
of the target state (which must be any state of the same state set).

If there is no condition given, it defaults to ``TRUE`` (1).

Block
^^^^^

.. productionlist::
   block: "{" `block_defns` `statements` "}"
   block_defns: `block_defns` `block_defn`
   block_defns: 
   block_defn: `decl`
   block_defn: `c_code`

Blocks are enclosed in matching (curly) braces. They may contain any
number of block definitions and afterwards any number of statements.

Block definitions are: declarations and embedded C code.

Statements and Expressions
--------------------------

Statements
^^^^^^^^^^

.. productionlist::
   statements: `statements` `statement`
   statements: 
   statement: "break" ";"
   statement: "continue" ";"
   statement: "state" `identifier` ";"
   statement: `c_code`
   statement: `block`
   statement: "if" "(" `expr` ")" `statement`
   statement: "if" "(" `expr` ")" `statement` "else" `statement`
   statement: "while" "(" `expr` ")" `statement`
   statement: `for_statement`
   statement: `opt_expr` ";"
   for_statement: "for" "(" `exprs` ";" `opt_expr` ";" `exprs` ")" `statement`

As can be seen, most C statements are supported. Not supported are
the switch/case statement and the return statement.

The *state change statement* is not borrowed from C; it is only available in a
state transition action block (i.e. after a when) and has the effect of
immediately jumping out of the action block, overriding the statically
specified new state (given after the block) with its state argument.

.. todo:: find out of the compiler guards against state changes in other
   action blocks.

Expressions
^^^^^^^^^^^

Formation rules for expressions are listed in groups of decending order
of precendence.

Atomic Expression
~~~~~~~~~~~~~~~~~

.. productionlist::
   expr: `integer_literal`
   expr: `floating_point_literal`
   expr: `string`
   expr: `identifier`
   string: `string_literal`

These are literals and variables.

Parenthesized Expression
~~~~~~~~~~~~~~~~~~~~~~~~

.. productionlist::
   expr: "(" `expr` ")"

Primary Expression Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. productionlist::
   expr: `identifier` "(" `exprs` ")"
   expr: "exit" "(" `exprs` ")"
   expr: `expr` "[" `expr` "]"
   expr: `expr` "." `expr`
   expr: `expr` "->" `expr`
   expr: `expr` "++"
   expr: `expr` "--"

These are: function call, array subscript, record selection, pointer to
record selection, and postfix operators (increment and decrement).

Note that :token:`exit` is listed explicitly because
it is a keyword, not an identifier, but can also be used as a function.

Note also that SNL makes no use of the semantics of structure member
access (a side-effect that you may notice is that the state notation
compiler will warn that structure tags are unused variables).

Unary Prefix Operators
~~~~~~~~~~~~~~~~~~~~~~

.. productionlist::
   expr: "+" `expr`
   expr: "-" `expr`
   expr: "*" `expr`
   expr: "&" `expr`
   expr: "!" `expr`
   expr: "~" `expr`
   expr: "++" `expr`
   expr: "--" `expr`

Left-associative Binary Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. productionlist::
   expr: `expr` "-" `expr`
   expr: `expr` "+" `expr`
   expr: `expr` "*" `expr`
   expr: `expr` "/" `expr`
   expr: `expr` ">" `expr`
   expr: `expr` ">=" `expr`
   expr: `expr` "==" `expr`
   expr: `expr` "!=" `expr`
   expr: `expr` "<=" `expr`
   expr: `expr` "<" `expr`
   expr: `expr` "||" `expr`
   expr: `expr` "&&" `expr`
   expr: `expr` "<<" `expr`
   expr: `expr` ">>" `expr`
   expr: `expr` "|" `expr`
   expr: `expr` "^" `expr`
   expr: `expr` "&" `expr`
   expr: `expr` "%" `expr`

Ternary Operator
~~~~~~~~~~~~~~~~

.. productionlist::
   expr: `expr` "?" `expr` ":" `expr`

The ternary operator (there is only one) is right-associative.

Assignment Operators
~~~~~~~~~~~~~~~~~~~~

.. productionlist::
   expr: `expr` "=" `expr`
   expr: `expr` "+=" `expr`
   expr: `expr` "-=" `expr`
   expr: `expr` "&=" `expr`
   expr: `expr` "|=" `expr`
   expr: `expr` "/=" `expr`
   expr: `expr` "*=" `expr`
   expr: `expr` "%=" `expr`
   expr: `expr` "<<=" `expr`
   expr: `expr` ">>=" `expr`
   expr: `expr` "^=" `expr`

These operators are right-associative.

Expression List
~~~~~~~~~~~~~~~

.. productionlist::
   exprs: `exprs` "," `expr`
   exprs: `expr`
   exprs: 

Comma separated expression lists are not expressions (in SNL), since
SNL does not support the comma operator. However, they appear as parts
of expressions and statements, and then have the same meaning as in C.


.. _BuiltinFunctions:

Built-in Functions
------------------

The following special functions are built into the SNL. In most
cases the state notation compiler performs some special
interpretation of the parameters to these functions. Therefore,
some are either not available through escaped C code or their use
in escaped C code is subject to special rules.

An argument specified as *assigned_var* refers to any SNL variable that is
assigned to a process variable. When using such a variable as a function
argument, the function is automatically given access to the details of the
underlying process variable.

Several of these functions are primarily intended to be called only from
:token:`when` clauses or only from action code. It is safe to call them in
action code, but the effect is probably not what you want. For instance,
calling :c:func:`delay` in action code does *not* introduce a delay at this
point. Later versions of *snc* may output a warning or even stop with an
error.

Functions returning ``int`` actually return a :ref:`pvStat` error
code unless otherwise spacified.

delay
^^^^^

.. c:function::
  int delay(double delay_in_seconds)

Returns ``TRUE`` if the specified time has elapsed since entering the
state. It should be used only within a :token:`when` expression.

The :option:`-t` state option (see `State Option`_) controls whether the
delay is measured from when the current state was entered from a different
state (:option:`-t`) or from any state, including itself (:option:`+t` ,
the default)

pvPut
^^^^^

.. c:function::
  int pvPut(assigned_var)
  int pvPut(assigned_var, SYNC)
  int pvPut(assigned_var, ASYNC)

Puts (or writes) the value of an SNL variable to the
underlying process variable. Returns the status
from the PV layer (e.g. ``pvStatOK`` for success).

By default, :c:func:`pvPut` does not wait for the put to be complete;
completion must be inferred by other means. The optional ``SYNC``
argument causes it to block on completion with a hard-coded timeout
of 10s. The optional ``ASYNC`` argument allows completion to be
checked via a subsequent call to :c:func:`pvPutComplete` (typically in a
:token:`when` clause).

Note that, when using channel access, the ``SYNC`` and ``ASYNC``
arguments result in use of ``ca_put_callback``; if neither
optional argument is specified, ``ca_put`` is called as with
previous versions.

pvPutComplete
^^^^^^^^^^^^^

.. c:function::
  int pvPutComplete(assigned_var)
  int pvPutComplete(array_name)
  int pvPutComplete(array_name, long any)
  int pvPutComplete(array_name, long any, long *pComplete)

Returns ``TRUE`` if the last put of this process variable has completed.
This call is appropriate only if :c:func:`pvPut` 's optional ``ASYNC``
argument was used.

The first form is appropriate when the SNL variable is a scalar.
However, it can also be an array (each of whose elements may be
assigned to a different process variable). In this case, the
single argument form returns ``TRUE`` if the last puts of all the
elements of the array have completed (the missing arguments are
implicitly ``0`` and ``NULL`` respectively). If ``any`` is ``TRUE``, then
the function returns ``TRUE`` if any put has completed since the last
call. If ``pComplete`` is non-NULL, it should be a ``long`` array of
the same length as the SNL variable and its elements will be set to
``TRUE`` if and only if the corresponding put has completed.

pvGet
^^^^^

.. c:function::
  int pvGet(assigned_var)
  int pvGet(assigned_var, SYNC)
  int pvGet(assigned_var, ASYNC)

Gets (or reads) the value of an SNL variable from the underlying process
variable. Returns the status from the PV layer (e.g.
``pvStatOK`` for success). By default, the state set will block until the
read operation is complete with a hard-coded timeout of 10s. The
asynchronous (:option:`+a`) compile option can be used to prevent this, in
which case completion can be checked via a subsequent call to
:c:func:`pvGetComplete` (typically in a :token:`when` clause).

The optional ``SYNC`` and ``ASYNC`` arguments override the compile option.
``SYNC`` blocks and so gives default behavior if :option:`+a` was not
specified; ``ASYNC`` doesn't block and so gives default behavior if
:option:`+a` was specified.

pvGetComplete
^^^^^^^^^^^^^

.. c:function::
  int pvGetComplete(assigned_var)

Returns ``TRUE`` if the last get of this process variable has completed,
i.e. the value in the variable is current. This call is appropriate only if
the asynchronous (:option:`+a`) compile option is specified or
:c:func:`pvGet` 's optional ``ASYNC`` argument was used.

Unlike :c:func:`pvPutComplete`, :c:func:`pvGetComplete` doesn't support
arrays.

pvGetQ
^^^^^^

.. c:function::
  int pvGetQ(assigned_var)
  int pvGetQ(array_name)

Removes the oldest value from a SNL variable's monitor queue (the variable
should have been associated with a queue and an event flag via the
:token:`syncq` statement) and updates the corresponding SNL variable.
Despite its name, this function is really closer to
:c:func:`efTestAndClear` than it is to :c:func:`pvGet`. It returns
``TRUE`` if the queue was not empty.

If the SNL variable is an array then the behavior is the same
regardless of whether the array name or an array element name is
specified. This is because a single queue is associated with the
entire array.

pvFreeQ
^^^^^^^

.. c:function::
  void pvFreeQ(assigned_var)

Deletes all entries from an SNL variable's queue and
clears the associated event flag (the variable should have been
associated with a queue and an event flag via the :token:`syncq`
statement).

As with :c:func:`pvGetQ`, if the SNL variable is an array then the
behavior is the same regardless of whether the array name or an
array element name is specified.

pvMonitor
^^^^^^^^^

.. c:function::
  int pvMonitor(assigned_var)

Initiates a monitor on the underlying process
variable.

pvStopMonitor
^^^^^^^^^^^^^

.. c:function::
  int pvStopMonitor(assigned_var)

Terminates a monitor on the underlying process
variable.

pvFlush
^^^^^^^

.. c:function::
  void pvFlush()

Causes the PV layer to flush its input-output buffer.
It just might be needed if performing asynchronous operations
*within* an action block (note that the buffer is always flushed on
exit from an action block).

pvCount
^^^^^^^

.. c:function::
  int pvCount(assigned_var)

Returns the element count associated with the process variable.

pvStatus
^^^^^^^^

.. c:function::
  pvStat pvStatus(assigned_var)

Returns the current alarm status for the process variable (e.g.
``pvStatHIHI`` , see :ref:`pvStat`). The status and severity are only valid
after either a :c:func:`pvGet` call has completed or a monitor has been
delivered.

pvSeverity
^^^^^^^^^^

.. c:function::
  pvSevr pvSeverity(assigned_var)

Returns the current alarm severity (e.g.
e.g.pvSevrMAJORe.g.). The notes above apply

pvTimeStamp
^^^^^^^^^^^

.. c:function::
  TS_STAMP pvTimeStamp(assigned_var)

Returns the time stamp for the last :c:func`pvGet` or monitor
of this variable. The compiler does recognize type TS_STAMP.
Therefore, variable declarations for this type should be in escaped
C code. This will generate a compiler warning, which can be
ignored.

pvAssign
^^^^^^^^

.. c:function::
  int pvAssign(var, process_variable_name)

Assigns or re-assigned the SNL variable ``var`` to
``process_variable_name``. If ``process_variable_name`` is an empty
string then ``var`` is de-assigned (not associated with any process
variable).

As usual, ``var`` can also be an array element.

Note: :c:func:`pvAssign` can only be called on variables (or array elements)
that have been statically marked as process variables using the
:token:`assign` syntax. An empty string may be used for the initial
assignment.

A better name for this function would be ``pvReassign``.

pvAssigned
^^^^^^^^^^

.. c:function::
  int pvAssigned(assigned_var)

Returns ``TRUE`` if the SNL variable is currently
assigned to a process variable.

pvConnected
^^^^^^^^^^^

.. c:function::
  int pvConnected(assigned_var)

Returns ``TRUE`` if the underlying process
variable is currently connected.

pvIndex
^^^^^^^

.. c:function::
  int pvIndex(assigned_var)

Returns the index associated with a process
variable. See `User Functions within the State Program`_.

pvChannelCount
^^^^^^^^^^^^^^

.. c:function::
  int pvChannelCount()

Returns the total number of process variables
associated with the state program.

pvAssignCount
^^^^^^^^^^^^^

.. c:function::
  int pvAssignCount()

Returns the total number of SNL variables in this
program that are assigned to underlying process variables.
Note: if all SNL variables are assigned then the following
expression is ``TRUE``::

  pvAssignCount() == pvChannelCount()

Each element of an SNL array counts as variable for the purposes of
:c:func:`pvAssignCount`.

pvConnectCount
^^^^^^^^^^^^^^

.. c:function::
  int pvConnectCount()

Returns the total number of underlying process
variables that are connected. Note: if all variables are connected
then the following expression is ``TRUE``::

  pvConnectCount() == pvChannelCount()

efSet
^^^^^

.. c:function::
  void efSet(event_flag)

Sets the event flag and causes the execution of the
:token:`when` statements for all state sets that are pending on this event
flag.

efTest
^^^^^^

.. c:function::
  int efTest(event_flag)

Returns ``TRUE`` if the event flag was set.

efClear
^^^^^^^

.. c:function::
  int efClear(event_flag)

Clears the event flag and causes the execution of the
:token:`when` statements for all state sets that are pending on this event
flag.

efTestAndClear
^^^^^^^^^^^^^^

.. c:function::
  int efTestAndClear(event_flag)

Clears the event flag and returns ``TRUE`` if the event
flag was set. It is intended for use within a :token:`when` clause.

macValueGet
^^^^^^^^^^^

.. c:function::
  char* macValueGet(char *macro_name)

Returns a pointer to a string that is the value for
the specified macro name. If the macro does not exist, it returns
``NULL``.

C Compatibility Features
------------------------

Escape to C Code
^^^^^^^^^^^^^^^^

Because the SNL does not support the full C language, C code may be
escaped in the program. The escaped code is not compiled by SNC,
but is passed the C compiler. There are two escape methods
allowed:

#. Any code between ``%%`` and the next newline character is escaped.
   Example::

    %% for (i=0; i < NVAL; i++) {

#. Any code between ``%{`` and ``}%`` is escaped. Example::

    %{
    extern float smooth();
    extern LOGICAL accelerator_mode;
    }%

If you are using the C pre-processor prior to compiling with *snc*,
and you wish to defer interpretation of a preprocessor directive,
then you should use the form::

  %%#include <ioLib.h>
  %%#include <abcLib.h>

Any variable declared in escaped C code and used in SNL code will
be flagged with a warning message by the SNC. However, it will be
passed on to the C compiler correctly.

User Functions within the State Program
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The last state set may be followed by C code, usually containing
one or more user-supplied functions. For example::

  program example
  ...
  /* last SNL statement */
  %{
    LOCAL float smooth (pArray, numElem)
    { ... }
  }%

There is little reason to do this, since a state program can of
course be linked against C libraries.

Calling pvGet etc. from C
^^^^^^^^^^^^^^^^^^^^^^^^^

The built-in SNL functions such as :c:func:`pvGet` cannot be directly used
in user-supplied functions. However, most of the built-in functions
have a C language equivalent, which begin with the prefix ``seq_``
(e.g. ``pvGet`` becomes ``seq_pvGet``). These C functions must pass a
parameter identifying the calling state program, and if a process
variable name is required, the index of that variable must
be supplied. This index is obtained via the :c:func:`pvIndex` function.
Furthermore, if the code is complied with the :option:`+r` option, the
database variables must be referenced as a structure element as
described in `Variable Modification for Reentrant Option`_
(this isn't a problem if individual SNL variables are passed as
parameters to C code, because the compiler will do the work).
Examination of the intermediate C code that the compiler produces
will indicate how to use the built-in functions and database
variables.

.. _reentrant option:

Variable Modification for Reentrant Option
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If the reentrant option (:option:`+r`) is specified to SNC then all
variables are made part of a structure. Suppose we have the
following declarations in the SNL::

  int sw1;
  float v5;
  short wf2[1024];

The C file will contain the following declaration::

  struct UserVar {
    int sw1;
    float v5;
    short wf2[1025];
  };

The sequencer allocates the structure area at run time and passes a
pointer to this structure into the state program. This structure
has the following type::

  struct UserVar *pVar;

Reference to variable ``sw1`` is made as::

  pVar->sw1

This conversion is automatically performed by the SNC for all SNL
statements, but you will have to handle escaped C code yourself.

Syntax Summary
--------------

.. include:: bnf.inc
